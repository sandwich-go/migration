// Code generated by optiongen. DO NOT EDIT.
// optiongen: github.com/timestee/optiongen

package migration

import (
	"sync/atomic"
	"unsafe"
)

// Conf should use NewConf to initialize it
type Conf struct {
	FileName   string `xconf:"file_name" usage:"migration 脚本名"`
	ScriptRoot string `xconf:"script_root" usage:"migration 脚本根路径"`
	CommitID   string `xconf:"commit_id" usage:"migration dir 脚本目录名"`
}

// NewConf new Conf
func NewConf(opts ...ConfOption) *Conf {
	cc := newDefaultConf()
	for _, opt := range opts {
		opt(cc)
	}
	if watchDogConf != nil {
		watchDogConf(cc)
	}
	return cc
}

// ApplyOption apply multiple new option and return the old ones
// sample:
// old := cc.ApplyOption(WithTimeout(time.Second))
// defer cc.ApplyOption(old...)
func (cc *Conf) ApplyOption(opts ...ConfOption) []ConfOption {
	var previous []ConfOption
	for _, opt := range opts {
		previous = append(previous, opt(cc))
	}
	return previous
}

// ConfOption option func
type ConfOption func(cc *Conf) ConfOption

// WithFileName migration 脚本名
func WithFileName(v string) ConfOption {
	return func(cc *Conf) ConfOption {
		previous := cc.FileName
		cc.FileName = v
		return WithFileName(previous)
	}
}

// WithScriptRoot migration 脚本根路径
func WithScriptRoot(v string) ConfOption {
	return func(cc *Conf) ConfOption {
		previous := cc.ScriptRoot
		cc.ScriptRoot = v
		return WithScriptRoot(previous)
	}
}

// WithCommitID migration dir 脚本目录名
func WithCommitID(v string) ConfOption {
	return func(cc *Conf) ConfOption {
		previous := cc.CommitID
		cc.CommitID = v
		return WithCommitID(previous)
	}
}

// InstallConfWatchDog the installed func will called when NewConf  called
func InstallConfWatchDog(dog func(cc *Conf)) { watchDogConf = dog }

// watchDogConf global watch dog
var watchDogConf func(cc *Conf)

// newDefaultConf new default Conf
func newDefaultConf() *Conf {
	cc := &Conf{}

	for _, opt := range [...]ConfOption{
		WithFileName("migration"),
		WithScriptRoot("."),
		WithCommitID(""),
	} {
		opt(cc)
	}

	return cc
}

// AtomicSetFunc used for XConf
func (cc *Conf) AtomicSetFunc() func(interface{}) { return AtomicConfSet }

// atomicConf global *Conf holder
var atomicConf unsafe.Pointer

// onAtomicConfSet global call back when  AtomicConfSet called by XConf.
// use ConfInterface.ApplyOption to modify the updated cc
// if passed in cc not valid, then return false, cc will not set to atomicConf
var onAtomicConfSet func(cc ConfInterface) bool

// InstallCallbackOnAtomicConfSet install callback
func InstallCallbackOnAtomicConfSet(callback func(cc ConfInterface) bool) { onAtomicConfSet = callback }

// AtomicConfSet atomic setter for *Conf
func AtomicConfSet(update interface{}) {
	cc := update.(*Conf)
	if onAtomicConfSet != nil && !onAtomicConfSet(cc) {
		return
	}
	atomic.StorePointer(&atomicConf, (unsafe.Pointer)(cc))
}

// AtomicConf return atomic *ConfVisitor
func AtomicConf() ConfVisitor {
	current := (*Conf)(atomic.LoadPointer(&atomicConf))
	if current == nil {
		defaultOne := newDefaultConf()
		if watchDogConf != nil {
			watchDogConf(defaultOne)
		}
		atomic.CompareAndSwapPointer(&atomicConf, nil, (unsafe.Pointer)(defaultOne))
		return (*Conf)(atomic.LoadPointer(&atomicConf))
	}
	return current
}

// all getter func
func (cc *Conf) GetFileName() string   { return cc.FileName }
func (cc *Conf) GetScriptRoot() string { return cc.ScriptRoot }
func (cc *Conf) GetCommitID() string   { return cc.CommitID }

// ConfVisitor visitor interface for Conf
type ConfVisitor interface {
	GetFileName() string
	GetScriptRoot() string
	GetCommitID() string
}

// ConfInterface visitor + ApplyOption interface for Conf
type ConfInterface interface {
	ConfVisitor
	ApplyOption(...ConfOption) []ConfOption
}
